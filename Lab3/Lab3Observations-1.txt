1. The first example program creates a pipe in which it uses 2 fork child processes to execute the command ls|more.
2. The second example program creates a pipe using 2 fork children and the input being the gcc file name and manipulates it to print it out in spaces. 
3. The third program creates a pipe and redirects it with std out and in using dup2(fds[x], x). dup2(fds[1], 1) means 1 being the std out that is inputed for the beginning of the pipe, which is the write. dup2(fds[0], 0) means 0 being the std in that is outputed at the end of the pipe, which is the read.
4. The fourth program is the same as the first except it executes the shell command cat/etc/passwd|grep root.
5. This program I implemented a fgets to allow user input, in which I have the producer have this message, send it through the pipe, and then have the consumer receive and print the message.
6. The output is two different iterative statements, one being "Hello from thread [] with iteration []" and the second being "Thread [] returned". Because of the CPU scheduler, it isn't a smooth loop and the 2 statements often take turns. The error is that the for loop is using the address of the array incrementor, i, and when creating the threads, each thread has its own copy of their pointer which is pointing to the same i value that main holds. So, when the i value changes, all the threads also see the i value change, and because the CPU schedular randomly schedules the threads and main i execution change, the threads could have repeats and missing i values. 
7. The fix for &i was to use (void *)(size_t)i which passes a pointer to each individual thread to find the size of t, which at the time of execution of each thread, would feed the pointer to the real-time value of t. 