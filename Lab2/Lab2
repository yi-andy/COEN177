Part 1: ./lab2example ran and gave this error: "Segmentation fault (core dumped). 
./lab2example 3000 ran the fork with the child and parent processes alternating generally from 0-99 with occasional double outputs were the child or process outputs twice in a row instead of alternating after 1. 
./lab2example 500 also forked with the parent and child processes alternating however the child process ended 4 iterations before the parent did. Ran more quickly than the n 3000.
./lab2example 5000 also forked and took longer than the previous runs, with the parent and child processes generally alternating correctly as they should be.
The example program ran correctly as it should.
Part 2: I used an iterative for loop where there will be 2 forks so that the tree created would intially be 2 children of the parent. Then with the second iteration of the for loop each of these children having 2 children of their own. I use break in order to return to the parent and therefore be able to fork again and create another child from the parent. Using if comparisons, I would fork when the process returns to the parent. 
Part 3: Thread program: I used a separate pointer function to iterate through 100x for each thread. In the main, I used the definitions to create two pointer threads and have proper arguments for them which includes a thread id to specify between the two different threads and n for the usleep argument. I used pthread_join then at the end to let the main system know to wait for that specific thread to end; therefore we use pthread_join for both threads. 
Part 4: Using the template from step 1, I pieced together the condition of the else if and else statements of that of in the doc. The else if handles the ls to show the files in the directory, and the else only occurs when the child process is done and the process is returned to the parent. 
