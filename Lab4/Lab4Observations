1. I ran threadHello.c which outputed a loop of threads and the thread number and id, and also which threads returned. I noticed when they say the thread number, it is out of order and repeated at times, which has to do with using the address of i. I get different results in terms of order and thread numbers and id when running several times, and if I'm also running another demanding process, it affects the order at which the threads run. So the thread could say that it completes before it has even outputed that it ran with the id and number. This shows the how running multiple programs affect the CPU scheduling. The variable i is a local variable in main that is a shared state, which is stored heap memory. The parameter arg is a local variable that is per-thread that is stored in the stack.
2. Without the 2nd for loop, the threads are not joined. Therefore, the main program does not wait for each thread to finish before continuing, therefore the last printf("Main thread done") could be outputed before the last thread even ends. 
3. For this third program, I used many threads to multiply 2 matrices together. I used a malloc, which stores in the heap memory, to store the 1st matrix row and 2nd matrix column elements as one int. Then, I have a multiply function which multiplies the row element by the columnn and add them, so the multiply function takes the row and column as threads and calculates a single element at a time. The error I receieved was errors when using large matrices, because I was calculating element by element with many threads. I didn't specify the size of malloc to be large enough, but fixed it by setting it to the n = size of row 1 * size of row 2 so it worked with the many threads. 
